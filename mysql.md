**mysql 最重要、最与众不同的特性是他的存储引擎架构**
优点是将**任务处理**与**存储**分离开来，可以在使用时根据性能、特性选择不同的数据存储方式。
存储引擎：Mysql中的数据是用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。
 
 **查询的大概流程：**客户端-->连接/线程处理-->查询缓存-->解析器-->优化器-->存储引擎。
**mysql的并发控制：**读锁和写锁，也叫共享锁和排它锁。
**所谓的锁策略：**就是在锁的开销和数据的安全性之间寻求平衡。（管理锁是需要开销的）
**表锁：**最基本的锁策略，会锁定整张表。
**行级锁：**最大程度支持并发处理，行级锁只在存储引擎层实现，而 MySQL 服务器层没有实现。
**事务：**
- 原子性：一个事务被视为一个不可分割的最小工作单元，要么成功要么失败。
- 一致性：数据库从一个一致性的状态转换到另一个一致性的状态。
- 隔离性：一个事务做的修改在提交之前，其他事务是不可见的。
- 持久性：一旦事务提交，所做的修改就会永久保存，即使系统崩溃，修改的数据也不会丢失

**隔离级别：**隔离性比想象的要复杂。SQL 标准中定义了四种隔离级别，每种级别都规定了一个事务中所做的修改，在那些事务内和事务间是可见的，那些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。
- **未提交读：**
	- 事务的修改，即使没提交，也对其他事务都可见。
	- 存在**脏读**问题，事务可以读取未提交的数据。
- **提交读：**
	- 事务从开始时，只能看见已经提交的事务所做的修改。
	- 存在**不可重读**问题，同一个事务多次查询结果不一致
- **可重复读：**
	- 同一个事务多次读取同样记录的结果是一致的。
	- mysql 默认事务隔离级别。
- **可串行化：**串行执行事务。没有并发。

ps： InnoDB 和 XtraDB 存储引擎通过多版本并发控制解决幻读的问题。
所谓幻读，是指事务在读取某范围记录时，另一个事务又在该范围插入新的记录。产生幻行。

**死锁：**数据库系统实现了各种死锁检测和死锁超时机制。InnoDB 的处理死锁的方法是，将持有最少行级排它锁的事务进行回滚。


**第三章 服务器性能剖析：**主要解决三个问题：
- 如何确认服务器是否达到了性能最佳的状态
- 找出某条语句为什么执行不够快
- 诊断被用户描述成“停顿”、“堆积” 或者 “卡死”的某些间歇性疑难故障。

定义性能最有效的方法是响应时间。

**第四章 Schema 与数据类型优化：**
mysql 提供两种相似的日期类型：DATETIME 和 TIMESTAMP
- DATETIME：能保存大范围的值从 1001 ～ 9999，精确度为秒。8个字节
- TIMESTAMP：保存了从 1970-01-01 00:00:00 以来的秒数，和 UNIX 时间戳相同。使用4个字节
应该尽量使用 TIMESTAMP，应为它比 DATETIME 空间效率更高。
[MySQL数据库TIMESTAMP设置默认值的灵活运用](http://database.51cto.com/art/201108/285917.htm)

**第五章 高性能的索引：**索引是在存储引擎层而不是服务器层实现的。
- **B+Tree 索引：**InnoDB 使用该索引，InnoDB按照原格式存储数据，不压缩数据。
- **哈希索引：**基于哈希表实现，只有 Memory 引擎显式支持哈希索引。Memory 引擎也同时支持 B-Tree 索引。
	- 哈希索引的限制：索引速度快，无法用于排序，部支持部分索引列匹配查找。只支持等值比较。如果哈希冲突很多，则索引的维护操作代价也会很高。
- **全文索引：**它查找的是文本中的关键词，而不是直接比较索引中的值，更类似于搜索引擎做的事情。

B-树是如何组织数据存储的：这样你能理解该索引对那些查询有效。
如：key(last_name, first_name, birthday)
则：索引为 jiang kui 1990-02-13 这种存储方式。
所以适用于最左前缀原则。
[B树、B-树、B+树、B*树](http://www.cnblogs.com/oldhorse/archive/2009/11/16/1604009.html)

InnoDB 引擎有一个特殊功能叫做“自适应哈希索引”，当某些索引值被使用的非常频繁，它会在内存中基于 B-Tree 索引之上在创建一个哈希索引
**创建自定义哈希索引：但哈希索引是需要自己写触发器维护的。P148**
哈希冲突的解决方法就是：where 子句中加上 and 查询。
>select id from url where url_crc=CRC32("http://www.mysql.com") and url = "http://www.mysql.com";