**mysql 最重要、最与众不同的特性是他的存储引擎架构**
优点是将**任务处理**与**存储**分离开来，可以在使用时根据性能、特性选择不同的数据存储方式。
存储引擎：Mysql中的数据是用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。
 
 **查询的大概流程：**客户端-->连接/线程处理-->查询缓存-->解析器-->优化器-->存储引擎。
**mysql的并发控制：**读锁和写锁，也叫共享锁和排它锁。
**所谓的锁策略：**就是在锁的开销和数据的安全性之间寻求平衡。（管理锁是需要开销的）
**表锁：**最基本的锁策略，会锁定整张表。
**行级锁：**最大程度支持并发处理，行级锁只在存储引擎层实现，而 MySQL 服务器层没有实现。
**事务：**
- 原子性：一个事务被视为一个不可分割的最小工作单元，要么成功要么失败。
- 一致性：数据库从一个一致性的状态转换到另一个一致性的状态。
- 隔离性：一个事务做的修改在提交之前，其他事务是不可见的。
- 持久性：一旦事务提交，所做的修改就会永久保存，即使系统崩溃，修改的数据也不会丢失

**隔离级别：**隔离性比想象的要复杂。SQL 标准中定义了四种隔离级别，每种级别都规定了一个事务中所做的修改，在那些事务内和事务间是可见的，那些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。
- **未提交读：**
	- 事务的修改，即使没提交，也对其他事务都可见。
	- 存在**脏读**问题，事务可以读取未提交的数据。
- **提交读：**
	- 事务从开始时，只能看见已经提交的事务所做的修改。
	- 存在**不可重读**问题，同一个事务多次查询结果不一致
- **可重复读：**
	- 同一个事务多次读取同样记录的结果是一致的。
	- mysql 默认事务隔离级别。
- **可串行化：**串行执行事务。没有并发。

ps： InnoDB 和 XtraDB 存储引擎通过多版本并发控制解决幻读的问题。
所谓幻读，是指事务在读取某范围记录时，另一个事务又在该范围插入新的记录。产生幻行。

**死锁：**数据库系统实现了各种死锁检测和死锁超时机制。InnoDB 的处理死锁的方法是，将持有最少行级排它锁的事务进行回滚。

待看
第三章 服务器性能po

第四章 Schema 与数据类型优化

第五章 高性能的索引

第六章 查询性能优化

7.11 分布式事务
7.12 查询缓存
